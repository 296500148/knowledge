# HTTP

## HTTP 0.9

* 只有GET请求

* 服务器只能回应HTML格式的字符串，不能回应别的格式

* 服务器发送完即关闭

## HTTP 1.0

* 结构变更,每次通信必须包含头信息(HTTP header)

* 增加了POST和HEAD

* 定义了一些头部字段(包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等)。

### HTTP 1.0缺点
* 每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。Connection: keep-alive 是解决方法不过是非标准的

## HTTP 1.1

* 连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。Connection: close可以主动关闭链接。允许建立的持久链接有限制(不同浏览器可能有不同的个数)

* 管道机制,以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求,但是服务器还是<span style="color:red">按照顺序，先回应A请求，完成后再回应B请求。<span>

原先:

``` mermaid
    sequenceDiagram
    participant C as 客户端
    participant S as 服务端
    C -->> S:A请求 
    S -->> C:A响应
    C -->> S:B请求 
    S -->> C:B响应
```

现在:

原先:

``` mermaid
    sequenceDiagram
    participant C as 客户端
    participant S as 服务端
    C -->> S:A请求 
    C -->> S:B请求 
    S -->> C:A响应
    S -->> C:B响应
```

* Content-Length 字段

* Transfer-Encoding : Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度

* 增加PUT、PATCH、OPTIONS、DELETE

### HTTP 1.1缺点

队头堵塞（Head-of-line blocking）：同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。<span style="color:red">要是前面的回应特别慢，后面就会有许多请求排队等着。</span>

### 如何解决HTTP 1.1缺点

一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。

## HTTP 2

前言:基于2009年谷歌自行研发的 SPDY 协议;不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3

* **二进制协议**:HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"。即头信息帧和数据帧。可以定义额外的帧

* **多工**:双向的、实时的通信，请求和响应不用按照顺序一一对应。解决HTTP 1.1的队头阻塞问题。

* **数据流**:因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

* **头信息压缩**:头信息使用gzip或compress压缩后再发送;客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了

* **服务器推送**:
HTTP/2 允许服务器未经请求，主动向客户端发送资源